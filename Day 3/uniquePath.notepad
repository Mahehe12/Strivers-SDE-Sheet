class Solution {
    public int uniquePaths(int m, int n) {
        // Brute Force Solution
        // TC: Exponential
        // SC: Stack Space

        return countPath(0, 0, m, n);
    }

    public static int countPath(int i, int j, int m, int n) {
        if (i == m - 1 && j == n - 1)
            return 1;
        if (i >= m || j >= n)
            return 0;

        return countPath(i + 1, j, m, n) + countPath(i, j + 1, m, n);
    }
}

class Solution {
    public int uniquePaths(int m, int n) {
        // Dynamic Programming Solution
        // TC: O(M * N)
        // SC: O(M * N)

        int dp[][] = new int[m][n];
        return countPath(0, 0, m, n, dp);
    }

    public static int countPath(int i, int j, int m, int n, int dp[][]) {
        if (i == m - 1 && j == n - 1)
            return 1;
        if (i >= m || j >= n)
            return 0;

        if(dp[i][j] != 0) return dp[i][j]; 

        return dp[i][j] = countPath(i + 1, j, m, n, dp) + countPath(i, j + 1, m, n, dp);
    }
}

class Solution {
    public int uniquePaths(int m, int n) {
        // Combinatorics Solution
        // TC: Min of  [ O(n-1)  or  O(m-1) ]
        // SC: O(1)

        int N = n + m - 2;
        int r = Math.min(m - 1, n - 1);
        double res = 1;

        for (int i = 1; i <= r; i++)
            res = res * (N - r + i) / i;
        return (int) res;
    }
}